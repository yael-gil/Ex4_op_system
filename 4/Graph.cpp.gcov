        -:    0:Source:Graph.cpp
        -:    0:Graph:Graph.gcno
        -:    0:Data:Graph.gcda
        -:    0:Runs:2
        -:    1:#include <vector>
        -:    2:#include <iostream>
        -:    3:#include <algorithm> // For std::find
        -:    4:
        -:    5:#include "Graph.hpp"
        -:    6:
        -:    7:
        -:    8:class Graph; 
        -:    9:void DFS(int start_node, std::vector<bool>& visited, const Graph& graph);
        -:   10:
        -:   11:
        -:   12:
        6:   13:        Graph::Graph(int V, bool directed) : V(V), adj(V), directed(directed) {}
        -:   14:
      873:   15:        void Graph::addEdge(int u, int v, int w) // Add edge from u to v
        -:   16:            {
      873:   17:                if (u < 0 || u >= V || v < 0 || v >= V)
        -:   18:                {
    #####:   19:                    std::cerr << "Error: Vertex out of bounds (addEdge)" << std::endl;
    #####:   20:                    return;
        -:   21:                }
      873:   22:				if(w < 0){
        -:   23:				 
    #####:   24:                    std::cerr << "Error: Negative weight not allowed (addEdge)" << std::endl;
    #####:   25:                    return;
        -:   26:                }
      873:   27:                if (u == v)
        -:   28:                {
    #####:   29:                    std::cerr << "Error: No self-loops allowed (addEdge)" << std::endl;
    #####:   30:                    return;
        -:   31:                }
        -:   32:
      873:   33:                if(isEdgeConnected(u, v))
        -:   34:                {
    #####:   35:                    std::cerr << "Error: Edge already exists (addEdge)" << std::endl;
    #####:   36:                    return;
        -:   37:                }
        -:   38:
      873:   39:                adj[u].push_back({v, w}); // Add edge from u to v
        -:   40:                
      873:   41:                if(!directed){
        3:   42:                    adj[v].push_back({u, w});  // For undirected graph
        -:   43:                }
        -:   44:            
        -:   45:            }
        -:   46:
        -:   47:		
       60:   48:        const std::vector<std::pair<int, int>>& Graph::getNeighbors(int v) const
        -:   49:            {
       60:   50:                if(v < 0 || v >= V)
        -:   51:                {
    #####:   52:                    std::cerr << "Error: Vertex out of bounds (getNeighbros)" << std::endl;
    #####:   53:                    static const std::vector<std::pair<int, int>> empty; // Return an empty vector on error
    #####:   54:                    return empty;
        -:   55:                }
       60:   56:                return adj[v];
        -:   57:            }
        -:   58:
    #####:   59:        int Graph::getNumVertices() const
        -:   60:            {
    #####:   61:                return V;
        -:   62:            }
        -:   63:
    #####:   64:		bool Graph::isDirected() const
        -:   65:            {
    #####:   66:                return directed;
        -:   67:            }
        -:   68:
     9531:   69:        bool Graph::isEdgeConnected(int u, int v) const // Check if there's an edge from u to v
        -:   70:            {
     9531:   71:                if (u < 0 || u >= V || v < 0 || v >= V)
        -:   72:                {
    #####:   73:                    std::cerr << "Error: Vertex out of bounds (isConnected)" << std::endl;
    #####:   74:                    return false;
        -:   75:                }
        -:   76:
   135297:   77:                for (std::pair neighbor : adj[u])
        -:   78:                {
   133551:   79:                    if (neighbor.first == v)
     7785:   80:                        return true;
        -:   81:                }
     1746:   82:                return false;
        -:   83:            }
        -:   84:
        -:   85:        
        2:   86:        void Graph::printGraph() const
        -:   87:            {
       37:   88:                for (int i = 0; i < V; ++i)
        -:   89:                {
       35:   90:                    std::cout << "Vertex " << i << ":";
      911:   91:                    for (std::pair<int,int> neighbor : adj[i])
        -:   92:                    {
      876:   93:                        std::cout << " " << neighbor.first << "(weight " << neighbor.second << ")";
        -:   94:                    }
       35:   95:                    std::cout << std::endl;
        -:   96:                }
        2:   97:            }
        4:   98:        int Graph::degree(int v) const // For undirected graphs
        -:   99:            {
        4:  100:                if (v < 0 || v >= V)
        -:  101:                {
    #####:  102:                    std::cerr << "Error: Vertex out of bounds (degree)" << std::endl;
    #####:  103:                    return -1;
        -:  104:                }
        4:  105:                if (directed)
        -:  106:                {
        2:  107:                    int in_deg = get_in_degree(v);
        2:  108:                    int out_deg = get_out_degree(v);
        2:  109:                    if (in_deg == -1 || out_deg == -1) // Error in in_degree or out_degree
    #####:  110:                        return -1;
        2:  111:                    return in_deg + out_deg; // Total degree is sum of in-degree and out-degree
        -:  112:                }
        -:  113:
        2:  114:                return adj[v].size(); // Degree in not directed graph is simply the size of the adjacency list
        -:  115:            }
        -:  116:        
       62:  117:        int Graph::get_in_degree(int v) const
        -:  118:        {
       62:  119:            if (v < 0 || v >= V)
        -:  120:            {
    #####:  121:                std::cerr << "Error: Vertex out of bounds (in_degree)" << std::endl;
    #####:  122:                return -1;
        -:  123:            }
        -:  124:
       62:  125:            int in_deg = 0;
     1922:  126:            for (int i = 0; i < V; ++i) // Iterate through all vertices
        -:  127:            {
    55800:  128:                for (const auto& neighbor : adj[i]) // Check their adjacency lists
        -:  129:                {
    53940:  130:                    if (neighbor.first == v) // If there's an edge to vertex v
        -:  131:                    {
     1798:  132:                        ++in_deg;
        -:  133:                    }
        -:  134:                }
        -:  135:            }
       62:  136:            return in_deg;
        -:  137:        }
        -:  138:
      123:  139:        int Graph::get_out_degree(int v) const
        -:  140:        {
      123:  141:            if (v < 0 || v >= V)
        -:  142:            {
    #####:  143:                std::cerr << "Error: Vertex out of bounds (out_degree)" << std::endl;
    #####:  144:                return -1;
        -:  145:            }
      123:  146:            return adj[v].size(); // Out-degree is simply the size of the adjacency list
        -:  147:        }
        -:  148:        
        3:  149:        bool Graph::isEulerian() const
        -:  150:        {
        -:  151:            // Find a vertex with a non-zero degree to start DFS
        3:  152:            int start_node = -1;
       3*:  153:            for (int i = 0; i < V; ++i) {
        3:  154:                if (degree(i) > 0) {
        3:  155:                    start_node = i;
        3:  156:                    break;
        -:  157:                }
        -:  158:            
        -:  159:            }
        -:  160:
        -:  161:            // The graph has no edges, it's connected trivially
        3:  162:            if (start_node == -1) {
    #####:  163:                return true;
        -:  164:            }   
        -:  165:
        3:  166:            if (directed){
       62:  167:                for(int j = 0; j < V; j++){
       60:  168:                    if(get_in_degree(j) != get_out_degree(j)){
    #####:  169:                        return false;
        -:  170:                    }
        -:  171:                }
        -:  172:            } else{
        -:  173:                // For undirected graph, check if all vertices have even degree
       1*:  174:                for (int i = 0; i < V; ++i)
        -:  175:            {
        1:  176:                if (degree(i) % 2 != 0) // If any vertex has an odd degree
        1:  177:                    return false;
        -:  178:            }
        -:  179:
        -:  180:            }
        -:  181:
        2:  182:            std::vector<bool> visited(V, false);
        -:  183:
        -:  184:            // Run DFS from the first non-isolated vertex
        2:  185:            DFS(start_node, visited, *this);
        -:  186:
        -:  187:            // Check if all non-isolated vertices were visited
       62:  188:            for (int i = 0; i < V; ++i) {
       60:  189:                if (directed){
      60*:  190:                    if(get_out_degree(i) > 0 && !visited[i]){
    #####:  191:                        return false;
        -:  192:                    }
        -:  193:                } else {
    #####:  194:                    if (degree(i) > 0 && !visited[i]) {
    #####:  195:                        return false; // Found an unvisited non-isolated vertex
        -:  196:                    }
        -:  197:            
        -:  198:                }
        -:  199:            }
        -:  200:            
        2:  201:            return true;
        2:  202:        }
        -:  203:
        1:  204:        void Graph::findEulerCircuit(){
        -:  205:            
        1:  206:            if (!isEulerian()) {
    #####:  207:                std::cout << "The graph is not Eulerian." << std::endl;
    #####:  208:                return;
        -:  209:            }
        -:  210:
        1:  211:            std::vector<std::vector<std::pair<int, int>>> tempAdj = adj; // Create a copy of the adjacency list
        1:  212:            std::vector<int> circuit; // To store the Eulerian circuit
        1:  213:            std::vector<int> stack; // Stack to hold the current path
        -:  214:
        1:  215:            int currVertex = 0;
        -:  216:
        -:  217:            // Start from the first vertex with edges
       1*:  218:            for (int i = 0; i < V; ++i) {
        1:  219:                    if (directed) {
        1:  220:                        if (get_out_degree(i) > 0) {
        1:  221:                            currVertex = i;
        1:  222:                            break;
        -:  223:                        }
        -:  224:                    } else {
    #####:  225:                        if (degree(i) > 0) {
    #####:  226:                            currVertex = i;
    #####:  227:                            break;
        -:  228:                        }
        -:  229:                    }
        -:  230:                }
        1:  231:                stack.push_back(currVertex);
        -:  232:
        -:  233:
     1742:  234:            while (!stack.empty()) {
     1741:  235:                if (tempAdj[currVertex].empty()) {
        -:  236:                    // If no more neighbors, add to circuit
      871:  237:                    circuit.push_back(currVertex);
      871:  238:                    currVertex = stack.back();
      871:  239:                    stack.pop_back();
        -:  240:                } else {
        -:  241:                    // Otherwise, continue traversing
      870:  242:                    stack.push_back(currVertex);
      870:  243:                    int nextVertex = tempAdj[currVertex].back().first;
        -:  244:                    // Remove the edge from the graph
      870:  245:                    tempAdj[currVertex].pop_back();
        -:  246:                    
        -:  247:                    // For undirected graph, remove the reverse edge as well
      870:  248:                    if (!directed) {
    #####:  249:                        auto it = std::find_if(tempAdj[nextVertex].begin(), tempAdj[nextVertex].end(),
    #####:  250:                                       [&](const auto& pair) { return pair.first == currVertex; });
    #####:  251:                        if (it != tempAdj[nextVertex].end()) {
    #####:  252:                            tempAdj[nextVertex].erase(it);
        -:  253:                        }
        -:  254:
        -:  255:                    }
      870:  256:                    currVertex = nextVertex;
        -:  257:                }
        -:  258:            }
        -:  259:
        -:  260:            // Print the Eulerian circuit
        1:  261:            std::cout << "Eulerian Circuit: ";
      872:  262:            for (auto it = circuit.rbegin(); it != circuit.rend(); ++it) {
      871:  263:                std::cout << *it << " ";
        -:  264:            }
        1:  265:            std::cout << std::endl;
        1:  266:        }
        -:  267:
        -:  268:
        -:  269:
       60:  270:void DFS(int start_node, std::vector<bool>& visited, const Graph& graph) {
        -:  271:    // Mark the current node as visited
       60:  272:    visited[start_node] = true;
       60:  273:    std::cout << start_node << " "; // Print the node
        -:  274:
        -:  275:    // Iterate through all neighbors of the current node
     1800:  276:    for (std::pair<int,int> neighbor : graph.getNeighbors(start_node)) {
        -:  277:        //  Recursively call DFS for unvisited neighbors
     1740:  278:        if (!visited[neighbor.first]) {
       58:  279:            DFS(neighbor.first, visited, graph);
        -:  280:        }
        -:  281:    }
       60:  282:}
        -:  283:
        -:  284:
